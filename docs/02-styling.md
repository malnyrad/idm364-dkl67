---
marp: true
class: invert
footer: 'Styling'
headingDivider: 4
math: katex
paginate: true
style: |
  section::after {
    font-size: 16px;
  }
theme: default
---

<style>
  pre {
    line-height: 1.5;
  }
  section.smaller h3 {
    color: #fafafa;
    font-size: 36px;
    height: 100vh;
    display: flex;
    align-items: flex-end;
  }
  section.center-title h1 {
    color: #fafafa;
    text-align: center;
  }
</style>

- [IDM364: Styling in Svelte](#idm364-styling-in-svelte)
- [Lesson Objectives](#lesson-objectives)
- [Styling with the style attribute](#styling-with-the-style-attribute)
  - [Messy, messy, messy](#messy-messy-messy)
- [Using style:directives](#using-styledirectives)
- [The `<style>` block](#the-style-block)
  - [How Svelte scopes CSS rules in a component](#how-svelte-scopes-css-rules-in-a-component)
  - [Adding the class attribute](#adding-the-class-attribute)
  - [Simplifying the class attribute with the `class:` directive](#simplifying-the-class-attribute-with-the-class-directive)
- [Applying styles from external CSS](#applying-styles-from-external-css)
- [Choosing a styling method](#choosing-a-styling-method)
  - [Incorporating SCSS or LESS](#incorporating-scss-or-less)

# IDM364: Styling in Svelte

# Lesson Objectives

* Styling with the style attribute
* Using style:directives
* The `<style>` block
* Applying styles from external CSS

# Styling with the style attribute

```html
<div style="color: blue" />

<div style="color: blue; font-size: 2rem" />

<div style="color: {color}" />
```

<!-- You can add inline styles to an element with the `style` attribute. Similar to HTML elements, you can add multiple CSS styling declarations. -->

<!-- The value of the `style` attribute is a string. You can form teh `style` attribute with dynamic expressions. -->

## Messy, messy, messy

```html
<div style="color: {color}; font-size: {font_size}; background: {background}; border-top: {border_top} />
```

<!-- Sometimes it gets messy when you have multiple CSS styling declarations within the `style` attribute. -->

# Using style:directives

<!-- Svelte provides `style:` directives, which allow you to split the `style` attribute into several attributes, which is hopefully more readable after adding line breaks and indentation. -->

<!-- The `style:` directive follows the following syntax: -->

```js
style:css-property-name={value}
```

---

```html
<div
  style:color="{color}"
  style:font-size="{font_size}"
  style:background="{background}"
  style:border-top="{border_top}"
/>
```

---

<!-- The CSS property name can be any CSS property, including CSS custom properties: -->

```html
<div style:--main-color="{color}" />
```

---

<!-- If the name of the style matches the name of the value it depends on, you can use the shorthand form of the `style:` directive: -->

```html
<div
  style:color
  style:font-size="{font_size}"
  style:background
  style:border-top="{border_top}"
/>
```

---

<!-- A style declared in the `style:` directive has a higher priority than the `style` attribute. In this example, the `h1` text is red. -->

```html
<div style:color="red" style="color: blue;" />
```

# The `<style>` block

<!-- In each Svelte component, you can have one top-level `<style>` block. Within the `<style>` block, you can have CSS rules, targeting elements within the component. -->

```html
<div>First div</div>
<div>Second div</div>

<style>
  div {
    color: blue;
  }
</style>
```

<!-- CSS rules withing the `<style>` block are scoped to the component, meaning the CSS rules will only apply to the elements within the component, and not `div` elements elsewhere in the application. -->

## How Svelte scopes CSS rules in a component

<!-- When Svelte compiles a component, the Svelte compiler goes through each CSS rule and attempts to match each element with the selector of the CSS rule: -->

```html
<div>row</div>

<style>
  div {
    color: red;
  }
</style>
```

<!-- Whenever an element matches the selector, the Svelte compiler will generate a CSS class name that is unique to the component and apply it to the element. -->

```html
<div class="svelte-q5jdbb">row</div>

<style>
  div.svelte-q5jdbb {
    color: red;
  }
</style>
```

<!-- Here, `svelte-q5jdbb` is the unique CSS class name that is generated by calculating the hash value of the CSS component. The has value will be different when the CSS content changes. This transformation happens during compilation by default. There's nothing additional that you need to do. -->

## Adding the class attribute

<!-- The CSS class selector in CSS works the same way in Svelte. When you add a `class` attribute to an element, you can target it using the CSS class selector. -->

```html
<div>First div</div>
<div class="highlight">Second div</div>

<style>
  .highlight {
    background-color: yellow;
  }
</style>
```

---

<!-- The value of the `class` attribute can be a string or dynamic expression. Here we conditionally apply classes to the element: -->

```html
<div class="{to_highlight ? "highlight" : ""} {to_bold ? "bold" : ""}" />
```

---

```html
<div class="{to_highlight ? "highlight" : ""} {to_bold ? "bold" : ""}" />

<div class="highlight bold" />
```

<!-- In this example, when the value of both `to_highlight` and `to_bold` is `true`, the `class` attribute value evaluates to `"highlight bold"`. -->

## Simplifying the class attribute with the `class:` directive

```javascript
class:class-name={condition}
```

```html
<div class:highlight="{to_highlight}" class:bold="{to_bold}" />

<!-- If the variable name was 'highlight' instead of 'to_highlight' -->
<div class:highlight />
```

<!-- This pattern of conditionally applying classes to an element based on a variable is so common that Svelte provides the `class:` directive to simplify it. -->

# Applying styles from external CSS

```html
<html>
  <head>
    <link rel="stylesheet" href="external.css" />
    <style>
      .title {
        color: blue;
      }
    </style>
  </head>
</html>
```

<!-- CSS rules written in the `<head>` are applied globally to all elements within your Svelte component. -->

<!-- Svelte's build tools (webpack, Rollup, Vite) are commonly configured to import CSS files using the `import` statement, similar to importing JavaScript files. -->

```javascript
import './style.css';
```

# Choosing a styling method

- `<style>` block over inline styles
- Control styles using the `style:` and `class:` directives
- Global CSS declarations for shared styles

<!-- These are my preferences, not requirements. -->

<!-- I find that inline styling clutters my workflow and makes my code harder to read. I prefer to have all my styles in one place in the `<style>` block. -->

<!-- When the style property of an element is dependent on a variable, I use the `style:` and `class:` directives instead of the `style` and `class` attributes, again for legibility. -->

<!-- Use global CSS for shared styles that apply to the entire application. -->

## Incorporating SCSS or LESS

<!-- As Svelte preprocesses your components during the build step, you have the flexibility to incorporate other languages like SCSS or Less. You can use Svelte's preprocessor API which hooks into these preprocessors. To use SCSS/SASS, you need to install node-sass or sass and then add a svelte.config.js file: -->

<!-- Install node-sass using `npm i -D node-sass` or sass using `npm i -D sass` -->

```bash
npm i -D sass
```

---

```js
// svelte.config.js
const sveltePreprocess = require('svelte-preprocess');

module.exports = {
  preprocess: sveltePreprocess({
    scss: {
      includePaths: ['src'],
    },
  }),
};
```

---

<!-- Now, you can write SCSS in your styles: -->

```html
<style lang="scss">
  $color: red;

  h1 {
    color: $color;

    span {
      font-weight: 300;
    }
  }
</style>

<h1>Hello world</h1>
```
